// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/float64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	tfTypes "github.com/speakeasy/terraform-provider-dub/internal/provider/types"
	"github.com/speakeasy/terraform-provider-dub/internal/sdk"
	speakeasy_float64validators "github.com/speakeasy/terraform-provider-dub/internal/validators/float64validators"
	speakeasy_objectvalidators "github.com/speakeasy/terraform-provider-dub/internal/validators/objectvalidators"
	speakeasy_stringvalidators "github.com/speakeasy/terraform-provider-dub/internal/validators/stringvalidators"
	"regexp"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &LinkResource{}
var _ resource.ResourceWithImportState = &LinkResource{}

func NewLinkResource() resource.Resource {
	return &LinkResource{}
}

// LinkResource defines the resource implementation.
type LinkResource struct {
	// Provider configured SDK client.
	client *sdk.Dub
}

// LinkResourceModel describes the resource data model.
type LinkResourceModel struct {
	Android         types.String                `tfsdk:"android"`
	Archived        types.Bool                  `tfsdk:"archived"`
	Clicks          types.Float64               `tfsdk:"clicks"`
	Comments        types.String                `tfsdk:"comments"`
	CreatedAt       types.String                `tfsdk:"created_at"`
	Description     types.String                `tfsdk:"description"`
	DoIndex         types.Bool                  `tfsdk:"do_index"`
	Domain          types.String                `tfsdk:"domain"`
	ExpiredURL      types.String                `tfsdk:"expired_url"`
	ExpiresAt       types.String                `tfsdk:"expires_at"`
	ExternalID      types.String                `tfsdk:"external_id"`
	FolderID        types.String                `tfsdk:"folder_id"`
	Geo             *tfTypes.LinkGeoTargeting   `tfsdk:"geo"`
	ID              types.String                `tfsdk:"id"`
	Image           types.String                `tfsdk:"image"`
	Ios             types.String                `tfsdk:"ios"`
	Key             types.String                `tfsdk:"key"`
	KeyLength       types.Float64               `tfsdk:"key_length"`
	LastClicked     types.String                `tfsdk:"last_clicked"`
	Leads           types.Float64               `tfsdk:"leads"`
	PartnerID       types.String                `tfsdk:"partner_id"`
	Password        types.String                `tfsdk:"password"`
	Prefix          types.String                `tfsdk:"prefix"`
	ProgramID       types.String                `tfsdk:"program_id"`
	ProjectID       types.String                `tfsdk:"project_id"`
	Proxy           types.Bool                  `tfsdk:"proxy"`
	PublicStats     types.Bool                  `tfsdk:"public_stats"`
	QrCode          types.String                `tfsdk:"qr_code"`
	Ref             types.String                `tfsdk:"ref"`
	Rewrite         types.Bool                  `tfsdk:"rewrite"`
	SaleAmount      types.Float64               `tfsdk:"sale_amount"`
	Sales           types.Float64               `tfsdk:"sales"`
	ShortLink       types.String                `tfsdk:"short_link"`
	TagID           types.String                `tfsdk:"tag_id"`
	TagIds          *tfTypes.CreateLinkTagIds   `tfsdk:"tag_ids"`
	TagNames        *tfTypes.CreateLinkTagNames `tfsdk:"tag_names"`
	Tags            []tfTypes.TagSchema         `tfsdk:"tags"`
	TenantID        types.String                `tfsdk:"tenant_id"`
	TestCompletedAt types.String                `tfsdk:"test_completed_at"`
	TestStartedAt   types.String                `tfsdk:"test_started_at"`
	TestVariants    []tfTypes.TestVariant       `tfsdk:"test_variants"`
	Title           types.String                `tfsdk:"title"`
	TrackConversion types.Bool                  `tfsdk:"track_conversion"`
	UpdatedAt       types.String                `tfsdk:"updated_at"`
	URL             types.String                `tfsdk:"url"`
	UserID          types.String                `tfsdk:"user_id"`
	UtmCampaign     types.String                `tfsdk:"utm_campaign"`
	UtmContent      types.String                `tfsdk:"utm_content"`
	UtmMedium       types.String                `tfsdk:"utm_medium"`
	UtmSource       types.String                `tfsdk:"utm_source"`
	UtmTerm         types.String                `tfsdk:"utm_term"`
	Video           types.String                `tfsdk:"video"`
	WebhookIds      []types.String              `tfsdk:"webhook_ids"`
	WorkspaceID     types.String                `tfsdk:"workspace_id"`
}

func (r *LinkResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_link"
}

func (r *LinkResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Link Resource",
		Attributes: map[string]schema.Attribute{
			"android": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The Android destination URL for the short link for Android device targeting.`,
			},
			"archived": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Whether the short link is archived. Defaults to ` + "`" + `false` + "`" + ` if not provided.`,
			},
			"clicks": schema.Float64Attribute{
				Computed:    true,
				Default:     float64default.StaticFloat64(0),
				Description: `The number of clicks on the short link. Default: 0`,
			},
			"comments": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The comments for the short link.`,
			},
			"created_at": schema.StringAttribute{
				Computed:    true,
				Description: `The date and time when the short link was created.`,
			},
			"description": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The custom link preview description (og:description). Will be used for Custom Link Previews if ` + "`" + `proxy` + "`" + ` is true. Learn more: https://d.to/og`,
			},
			"do_index": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Allow search engines to index your short link. Defaults to ` + "`" + `false` + "`" + ` if not provided. Learn more: https://d.to/noindex`,
			},
			"domain": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The domain of the short link. If not provided, the primary domain for the workspace will be used (or ` + "`" + `dub.sh` + "`" + ` if the workspace has no domains).`,
				Validators: []validator.String{
					stringvalidator.UTF8LengthAtMost(190),
				},
			},
			"expired_url": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The URL to redirect to when the short link has expired.`,
			},
			"expires_at": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The date and time when the short link will expire at.`,
			},
			"external_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The ID of the link in your database. If set, it can be used to identify the link in future API requests (must be prefixed with 'ext_' when passed as a query parameter). This key is unique across your workspace.`,
				Validators: []validator.String{
					stringvalidator.UTF8LengthBetween(1, 255),
				},
			},
			"folder_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The unique ID existing folder to assign the short link to.`,
			},
			"geo": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"ad": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ae": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"af": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ag": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ai": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"al": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"am": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ao": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"aq": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ar": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"as": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"at": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"au": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"aw": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ax": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"az": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ba": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bb": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bd": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"be": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bf": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bg": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bh": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bi": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bj": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bl": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bm": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bn": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bo": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bq": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"br": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bs": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bt": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bv": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bw": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"by": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"bz": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ca": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cc": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cd": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cf": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cg": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ch": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ci": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ck": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cl": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cm": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cn": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"co": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cr": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cu": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cv": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cw": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cx": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cy": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"cz": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"de": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"dj": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"dk": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"dm": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"do": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"dz": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ec": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ee": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"eg": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"eh": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"er": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"es": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"et": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"fi": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"fj": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"fk": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"fm": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"fo": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"fr": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ga": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gb": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gd": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ge": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gf": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gg": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gh": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gi": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gl": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gm": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gn": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gp": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gq": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gr": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gs": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gt": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gu": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gw": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"gy": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"hk": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"hm": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"hn": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"hr": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ht": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"hu": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ie": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"il": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"im": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"in": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"io": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"iq": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ir": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"is": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"it": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"je": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"jm": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"jo": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"jp": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ke": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"kg": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"kh": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ki": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"km": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"kn": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"kp": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"kr": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"kw": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ky": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"kz": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"la": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"lb": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"lc": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"li": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"lk": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"lr": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ls": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"lt": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"lu": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"lv": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ly": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ma": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mc": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"md": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"me": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mf": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mg": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mh": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mk": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ml": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mm": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mn": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mo": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mp": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mq": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mr": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ms": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mt": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mu": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mv": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mw": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mx": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"my": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"mz": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"na": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"nc": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ne": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"nf": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ng": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ni": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"nl": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"no": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"np": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"nr": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"nu": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"nz": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"om": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"pa": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"pe": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"pf": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"pg": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ph": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"pk": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"pl": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"pm": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"pn": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"pr": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ps": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"pt": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"pw": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"py": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"qa": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"re": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ro": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"rs": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ru": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"rw": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sa": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sb": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sc": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sd": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"se": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sg": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sh": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"si": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sj": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sk": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sl": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sm": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sn": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"so": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sr": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ss": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"st": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sv": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sx": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sy": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"sz": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tc": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"td": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tf": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tg": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"th": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tj": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tk": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tl": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tm": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tn": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"to": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tr": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tt": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tv": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tw": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"tz": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ua": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ug": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"um": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"us": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"uy": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"uz": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"va": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"vc": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ve": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"vg": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"vi": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"vn": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"vu": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"wf": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ws": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"xk": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"ye": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"yt": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"za": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"zm": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
					"zw": schema.StringAttribute{
						Computed: true,
						Optional: true,
					},
				},
				Description: `Geo targeting information for the short link in JSON format ` + "`" + `{[COUNTRY]: https://example.com }` + "`" + `.`,
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `The unique ID of the short link.`,
			},
			"image": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The custom link preview image (og:image). Will be used for Custom Link Previews if ` + "`" + `proxy` + "`" + ` is true. Learn more: https://d.to/og`,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile(`^data:image\/(png|jpeg|jpg|gif|webp);base64,`), "must match pattern "+regexp.MustCompile(`^data:image\/(png|jpeg|jpg|gif|webp);base64,`).String()),
				},
			},
			"ios": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The iOS destination URL for the short link for iOS device targeting.`,
			},
			"key": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The short link slug. If not provided, a random 7-character slug will be generated.`,
				Validators: []validator.String{
					stringvalidator.UTF8LengthAtMost(190),
				},
			},
			"key_length": schema.Float64Attribute{
				Optional: true,
				PlanModifiers: []planmodifier.Float64{
					float64planmodifier.RequiresReplaceIfConfigured(),
				},
				Description: `The length of the short link slug. Defaults to 7 if not provided. When used with ` + "`" + `prefix` + "`" + `, the total length of the key will be ` + "`" + `prefix.length + keyLength` + "`" + `. Requires replacement if changed.`,
				Validators: []validator.Float64{
					float64validator.Between(3, 190),
				},
			},
			"last_clicked": schema.StringAttribute{
				Computed:    true,
				Description: `The date and time when the short link was last clicked.`,
			},
			"leads": schema.Float64Attribute{
				Computed:    true,
				Default:     float64default.StaticFloat64(0),
				Description: `The number of leads the short links has generated. Default: 0`,
			},
			"partner_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The ID of the partner the short link is associated with.`,
			},
			"password": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The password required to access the destination URL of the short link.`,
			},
			"prefix": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Description: `The prefix of the short link slug for randomly-generated keys (e.g. if prefix is ` + "`" + `/c/` + "`" + `, generated keys will be in the ` + "`" + `/c/:key` + "`" + ` format). Will be ignored if ` + "`" + `key` + "`" + ` is provided. Requires replacement if changed.`,
			},
			"program_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The ID of the program the short link is associated with.`,
			},
			"project_id": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: `This will be removed in a future release, please migrate away from it as soon as possible`,
				Description:        `The project ID of the short link. This field is deprecated – use ` + "`" + `workspaceId` + "`" + ` instead.`,
			},
			"proxy": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Whether the short link uses Custom Link Previews feature. Defaults to ` + "`" + `false` + "`" + ` if not provided.`,
			},
			"public_stats": schema.BoolAttribute{
				Computed:           true,
				Optional:           true,
				DeprecationMessage: `This will be removed in a future release, please migrate away from it as soon as possible`,
				Description:        `Deprecated: Use ` + "`" + `dashboard` + "`" + ` instead. Whether the short link's stats are publicly accessible. Defaults to ` + "`" + `false` + "`" + ` if not provided.`,
			},
			"qr_code": schema.StringAttribute{
				Computed:    true,
				Description: `The full URL of the QR code for the short link (e.g. ` + "`" + `https://api.dub.co/qr?url=https://dub.sh/try` + "`" + `).`,
			},
			"ref": schema.StringAttribute{
				Optional:    true,
				Description: `The referral tag of the short link. If set, this will populate or override the ` + "`" + `ref` + "`" + ` query parameter in the destination URL.`,
			},
			"rewrite": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Whether the short link uses link cloaking. Defaults to ` + "`" + `false` + "`" + ` if not provided.`,
			},
			"sale_amount": schema.Float64Attribute{
				Computed:    true,
				Default:     float64default.StaticFloat64(0),
				Description: `The total dollar amount of sales the short links has generated (in cents). Default: 0`,
			},
			"sales": schema.Float64Attribute{
				Computed:    true,
				Default:     float64default.StaticFloat64(0),
				Description: `The number of sales the short links has generated. Default: 0`,
			},
			"short_link": schema.StringAttribute{
				Computed:    true,
				Description: `The full URL of the short link, including the https protocol (e.g. ` + "`" + `https://dub.sh/try` + "`" + `).`,
			},
			"tag_id": schema.StringAttribute{
				Computed:           true,
				Optional:           true,
				DeprecationMessage: `This will be removed in a future release, please migrate away from it as soon as possible`,
				Description:        `The unique ID of the tag assigned to the short link. This field is deprecated – use ` + "`" + `tagIds` + "`" + ` instead.`,
			},
			"tag_ids": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"array_of_str": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Validators: []validator.List{
							listvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("str"),
							}...),
						},
					},
					"str": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("array_of_str"),
							}...),
						},
					},
				},
				Description: `The unique IDs of the tags assigned to the short link.`,
			},
			"tag_names": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"array_of_str": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Validators: []validator.List{
							listvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("str"),
							}...),
						},
					},
					"str": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("array_of_str"),
							}...),
						},
					},
				},
				Description: `The unique name of the tags assigned to the short link (case insensitive).`,
			},
			"tags": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"color": schema.StringAttribute{
							Computed:    true,
							Description: `The color of the tag. must be one of ["red", "yellow", "green", "blue", "purple", "pink", "brown"]`,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"red",
									"yellow",
									"green",
									"blue",
									"purple",
									"pink",
									"brown",
								),
							},
						},
						"id": schema.StringAttribute{
							Computed:    true,
							Description: `The unique ID of the tag.`,
						},
						"name": schema.StringAttribute{
							Computed:    true,
							Description: `The name of the tag.`,
						},
					},
				},
				Description: `The tags assigned to the short link.`,
			},
			"tenant_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The ID of the tenant that created the link inside your system. If set, it can be used to fetch all links for a tenant.`,
				Validators: []validator.String{
					stringvalidator.UTF8LengthAtMost(255),
				},
			},
			"test_completed_at": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The date and time when the tests were or will be completed.`,
			},
			"test_started_at": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The date and time when the tests started.`,
			},
			"test_variants": schema.ListNestedAttribute{
				Computed: true,
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					Attributes: map[string]schema.Attribute{
						"percentage": schema.Float64Attribute{
							Computed:    true,
							Optional:    true,
							Description: `Not Null`,
							Validators: []validator.Float64{
								speakeasy_float64validators.NotNull(),
								float64validator.Between(10, 90),
							},
						},
						"url": schema.StringAttribute{
							Computed:    true,
							Optional:    true,
							Description: `Not Null`,
							Validators: []validator.String{
								speakeasy_stringvalidators.NotNull(),
							},
						},
					},
				},
				Description: `An array of A/B test URLs and the percentage of traffic to send to each URL.`,
				Validators: []validator.List{
					listvalidator.SizeAtLeast(2),
					listvalidator.SizeAtMost(4),
				},
			},
			"title": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The custom link preview title (og:title). Will be used for Custom Link Previews if ` + "`" + `proxy` + "`" + ` is true. Learn more: https://d.to/og`,
			},
			"track_conversion": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Whether to track conversions for the short link. Defaults to ` + "`" + `false` + "`" + ` if not provided.`,
			},
			"updated_at": schema.StringAttribute{
				Computed:    true,
				Description: `The date and time when the short link was last updated.`,
			},
			"url": schema.StringAttribute{
				Required:    true,
				Description: `The destination URL of the short link.`,
			},
			"user_id": schema.StringAttribute{
				Computed:    true,
				Description: `The user ID of the creator of the short link.`,
			},
			"utm_campaign": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The UTM campaign of the short link. If set, this will populate or override the UTM campaign in the destination URL.`,
			},
			"utm_content": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The UTM content of the short link. If set, this will populate or override the UTM content in the destination URL.`,
			},
			"utm_medium": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The UTM medium of the short link. If set, this will populate or override the UTM medium in the destination URL.`,
			},
			"utm_source": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The UTM source of the short link. If set, this will populate or override the UTM source in the destination URL.`,
			},
			"utm_term": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The UTM term of the short link. If set, this will populate or override the UTM term in the destination URL.`,
			},
			"video": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The custom link preview video (og:video). Will be used for Custom Link Previews if ` + "`" + `proxy` + "`" + ` is true. Learn more: https://d.to/og`,
			},
			"webhook_ids": schema.ListAttribute{
				Computed:    true,
				Optional:    true,
				ElementType: types.StringType,
				Description: `An array of webhook IDs to trigger when the link is clicked. These webhooks will receive click event data.`,
			},
			"workspace_id": schema.StringAttribute{
				Computed:    true,
				Description: `The workspace ID of the short link.`,
			},
		},
	}
}

func (r *LinkResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.Dub)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.Dub, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *LinkResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *LinkResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsCreateLinkRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Links.CreateLink(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.LinkSchema != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedLinkSchema(ctx, res.LinkSchema)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetLinkInfoRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.Links.GetLinkInfo(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.LinkSchema != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedLinkSchema(ctx, res1.LinkSchema)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *LinkResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *LinkResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsGetLinkInfoRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Links.GetLinkInfo(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.LinkSchema != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedLinkSchema(ctx, res.LinkSchema)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *LinkResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *LinkResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsUpdateLinkRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Links.UpdateLink(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.LinkSchema != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedLinkSchema(ctx, res.LinkSchema)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetLinkInfoRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.Links.GetLinkInfo(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.LinkSchema != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedLinkSchema(ctx, res1.LinkSchema)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *LinkResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *LinkResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsDeleteLinkRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Links.DeleteLink(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *LinkResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
}
